use num::One;
use num_bigint::BigUint;
use num_complex::Complex;
fn miller_rabin_primality(num: &BigUint) -> bool {
    let small_primes: Vec<u32> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
    // let largest_small_prime = small_primes[small_primes.len() - 1];
    for prime in small_primes {
        if num % prime == BigUint::ZERO {
            return false;
        }
    }
    fn even_exp_factorize(num: &BigUint) -> (BigUint, u64) {
        let exp = num.trailing_zeros();
        if let Some(exp) = exp {
            let odd = num << exp;
            return (odd, exp);
        }
        panic!("num is zero");
    }

    fn miller_rabin_iteration(
        witness: u32,
        z: &BigUint,
        z_odd: &BigUint,
        z_exp: u64,
        num: &BigUint,
    ) -> bool {
        // Choose a witness between 2 and n-2
        let mut x = BigUint::from(witness).modpow(z_odd, num);
        if x.is_one() {
            return true;
        }
        for _ in 0..z_exp {
            if &x == z {
                return true;
            }
            x = x.pow(2) % num;
            if x.is_one() {
                return false;
            }
        }
        false
    }
    let z = num - (1 as u32);
    let (z_odd, z_exp) = even_exp_factorize(&z);

    for witness in [2, 7, 61] {
        if !miller_rabin_iteration(witness, &z, &z_odd, z_exp, num) {
            return false;
        }
    }
    true
}

fn eitau_real(x: &f32) -> Complex<f32> {
    Complex::new(x.cos(), x.sin())
}

fn slow_fourier_transform(sequence: &Vec<Complex<f32>>) -> Vec<Complex<f32>> {
    let mut res: Vec<Complex<f32>> = Vec::new();
    for i in 0..sequence.len() {
        let mut sum = Complex::new(0.0, 0.0);
        for j in 0..sequence.len() {
            sum += sequence[j] * eitau_real(&((i * j) as f32 / sequence.len() as f32));
        }
        res.push(sum);
    }
    res
}

// A(x)=a_n x^(n) + a_(n-1) x^(n-1) + ... + a_1 x + a_0
// This polynomial needs to be evaulated at n different values of x
// For two polynomials, then Odd(x)=-Odd(-x), and Even(x)=Even(-x)
// For every polynomial A(x) = B(x^2) + xC(x^2)
// And therefore A(-x) = B(x^2) - xC(x^2)
// So for any polynomial, we can compute A(-x) and A(x) at the same time.
// Ideally we want to do the same for B(x), and C(x), but in order to get a good set of pairs, we
// evaluate ut at zeta, where zeta^(2^n)-1=0
// then for B(x) and C(x) have to be evaulated at zeta^(2^(n-1)). Half the valuations of
// previously.
// What I dont understand is how to generalize this outside powers of 2.
// One spoiler free wikipedia glance and I got that it only works for composites, and cant break
// down primes. Thats helpful. We can see that it can split off factors of 2. How about 3?
//
// Split A(x) = B(x^3) + xC(x^3) + x^2D(x^3)
// Then let w^3=1. Then we should have
// A(x) = B(x^3) + xC(x^3) + x^2D(x^3)
// A(wx) = B(w^3x^3) + wxC(w^3x^3) + w^2x^2D(w^3x^3) = B(x^3) + wxC(x^3) + w^2x^2D(x^3)
// A(w^2x) = B(w^6x^3) + w^2xC(w^6x^3) + w^4x^2D(w^6x^3) = B(x^3) + w^2xC(x^3) + wx^2D(x^3)
// also
// more generally any polynomial P(x) with order pq, can be split
// P(x) = sum [x^i*P_i(x^p) for i in 0..p]
// and for any zeta^(p)-1=0
// P(zeta^k) = sum [x^i zeta^ik * P_i(x^p) for i in 0..p]
// So how much does it cost to compute the whole DFT for zeta^pq -1 =0, how much does
// computing P(zeta^k) for k=0..pq cost? (assuming p and q prime so I dont have to think about
// recursion)
//
// All of the P_i(x^p) have order q, and you need to compute a slow DFT for each of them, and there
// is p of them. So the total cost for the compute step is O(pq^2), then for the entire combination
// process needs to be run q times for each result DFT generated by the sub polynomials. And each
// process involves doing p multiplications p times. So the cost of the combo process is O(p^2q).
// Giving us a total cost of O(p q^2 + p^2 q), compared to the slow DFT of O(p^2 q^2). I understand
// why this is only presented as a solution for powers of 2 lol. Although for pq=n and p roughly
// the same size as q. This does go from (n^2) to (n* sqrt(n))
fn fast_fourier_transform(sequence: &Vec<Complex<f32>>) -> Vec<Complex<f32>> {
    return slow_fourier_transform(sequence);
}
