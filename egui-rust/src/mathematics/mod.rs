use std::usize;

use num::{FromPrimitive, One, ToPrimitive};
use num_bigint::BigUint;
use num_complex::Complex;
use rand::Rng;

pub mod primes;

fn eitau_real(x: &f32) -> Complex<f32> {
    let z = x * std::f32::consts::TAU;
    Complex::new(z.cos(), z.sin())
}

fn slow_fourier_transform(sequence: &[Complex<f32>]) -> Vec<Complex<f32>> {
    let mut res: Vec<Complex<f32>> = Vec::new();
    for i in 0..sequence.len() {
        let mut sum = Complex::new(0.0, 0.0);
        for j in 0..sequence.len() {
            sum += sequence[j] * eitau_real(&((i * j) as f32 / sequence.len() as f32));
        }
        res.push(sum);
    }
    res
}

// A(x)=a_n x^(n) + a_(n-1) x^(n-1) + ... + a_1 x + a_0
// This polynomial needs to be evaulated at n different values of x
// For two polynomials, then Odd(x)=-Odd(-x), and Even(x)=Even(-x)
// For every polynomial A(x) = B(x^2) + xC(x^2)
// And therefore A(-x) = B(x^2) - xC(x^2)
// So for any polynomial, we can compute A(-x) and A(x) at the same time.
// Ideally we want to do the same for B(x), and C(x), but in order to get a good set of pairs, we
// evaluate ut at zeta, where zeta^(2^n)-1=0
// then for B(x) and C(x) have to be evaulated at zeta^(2^(n-1)). Half the valuations of
// previously.
// What I dont understand is how to generalize this outside powers of 2.
// One spoiler free wikipedia glance and I got that it only works for composites, and cant break
// down primes. Thats helpful. We can see that it can split off factors of 2. How about 3?
//
// Split A(x) = B(x^3) + xC(x^3) + x^2D(x^3)
// Then let w^3=1. Then we should have
// A(x) = B(x^3) + xC(x^3) + x^2D(x^3)
// A(wx) = B(w^3x^3) + wxC(w^3x^3) + w^2x^2D(w^3x^3) = B(x^3) + wxC(x^3) + w^2x^2D(x^3)
// A(w^2x) = B(w^6x^3) + w^2xC(w^6x^3) + w^4x^2D(w^6x^3) = B(x^3) + w^2xC(x^3) + wx^2D(x^3)
// also
// more generally any polynomial P(x) with order pq, can be split
// P(x) = sum [x^i*P_i(x^p) for i in 0..p]
// and for any zeta^(p)-1=0
// P(zeta^k) = sum [x^i zeta^ik * P_i(x^p) for i in 0..p]
// So how much does it cost to compute the whole DFT for zeta^pq -1 =0, how much does
// computing P(zeta^k) for k=0..pq cost? (assuming p and q prime so I dont have to think about
// recursion)
//
// All of the P_i(x^p) have order q, and you need to compute a slow DFT for each of them, and there
// are p of them. So the total cost for the compute step is O(pq^2), then for the entire combination
// process needs to be run q times for each result DFT generated by the sub polynomials. And each
// process involves doing p multiplications p times. So the cost of the combo process is O(p^2q).
// Giving us a total cost of O(p q^2 + p^2 q), compared to the slow DFT of O(p^2 q^2). I understand
// why this is only presented as a solution for powers of 2 lol. Although for pq=n and p roughly
// the same size as q. This does go from (n^2) to (n* sqrt(n))
fn fast_fourier_transform_recursive(
    sequence: &[Complex<f32>],
    length_factorized: &[usize],
) -> Vec<Complex<f32>> {
    let length = length_factorized.iter().fold(1, |a, b| a * b);
    if sequence.len() != length {
        panic!("Lengths do not match");
    }
    if length_factorized.len() == 1 {
        return slow_fourier_transform(sequence);
    }
    let main_prime = length_factorized[0];
    let leftovers = sequence.len() / main_prime;
    let mut smaller_polynomials: Vec<Vec<Complex<f32>>> = vec![vec![]; main_prime];
    for i in 0..main_prime {
        for j in 0..leftovers {
            smaller_polynomials[i].push(sequence[i + j * main_prime]);
        }
    }
    let leftover_factorized = &(length_factorized[1..].to_vec());
    let small_fourier = |sub_sequence: &Vec<Complex<f32>>| -> Vec<Complex<f32>> {
        fast_fourier_transform_recursive(sub_sequence, leftover_factorized)
    };
    let sub_fourier_results: Vec<Vec<Complex<f32>>> =
        smaller_polynomials.iter().map(small_fourier).collect();
    let mut fourier_return: Vec<Complex<f32>> = vec![Complex::ZERO; length];
    for j in 0..leftovers {
        for i in 0..main_prime {
            let mut sum = Complex::ZERO;
            for k in 0..main_prime {
                sum +=
                    sub_fourier_results[k][j] * eitau_real(&((i * k) as f32 / main_prime as f32));
            }
            fourier_return[j * main_prime + i] = sum;
        }
    }
    fourier_return
}

// fn numerical_differential_inverse(
//     f: impl Fn(&f64) -> f64,
//     fprime: impl Fn(&f64) -> f64,
// ) -> impl Fn(&f64) -> f64 {
//     move |x: &f64| -> f64 {
//         let newton_func = |z| f(z) - x;
//         let inverse = newtons_method_rootfind_primative(newton_func, fprime, x);
//         inverse
//     }
// }
// fn newtons_method_rootfind_primative(
//     f: impl Fn(&f64) -> f64,
//     fprime: impl Fn(&f64) -> f64,
//     guess: &f64,
// ) -> f64 {
//     let mut iterator_guess = guess - f(guess) / fprime(guess);
//     const MAX_ITER: u32 = 5;
//     for _ in 0..MAX_ITER {
//         iterator_guess = iterator_guess - f(&iterator_guess) / fprime(&iterator_guess);
//     }
//     return iterator_guess;
// }
//
// fn hallys_method_rootfind_primative(
//     f: impl Fn(&f64) -> f64,
//     fprime: impl Fn(&f64) -> f64,
//     fprimeprime: impl Fn(&f64) -> f64,
//     guess: f64,
// ) -> f64 {
//     let mut iterator_guess = guess;
//     const MAX_ITER: u32 = 5;
//     for _ in 0..MAX_ITER {
//         iterator_guess = iterator_guess
//             - 2.0 * (f(&iterator_guess) * fprime(&iterator_guess))
//                 / (2.0 * fprime(&iterator_guess).powf(2.0)
//                     - f(&iterator_guess) * fprimeprime(&iterator_guess));
//     }
//     return iterator_guess;
// }
